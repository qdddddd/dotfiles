" vim: set sw=4 ts=4 sts=4 et foldmarker={,} foldlevel=0 foldmethod=marker:

" Environment {

    " Identify platform {
        silent function! OSX()
            return has('macunix')
        endfunction

        silent function! LINUX()
            return has('unix') && !has('macunix') && !has('win32unix')
        endfunction
    " }

    " Basics {
        set nocompatible        " Must be first line
    " }
" }

" Load bundles config {

    " Plugin setteings before loading
    let g:ale_completion_enabled = 0
    "let g:ale_completion_delay = 0
    let g:ale_echo_cursor = 0
    let g:ale_cursor_detail = 1

    if filereadable(expand("~/.vim/vimrc.bundles"))
        source ~/.vim/vimrc.bundles
    endif
" }

" General {
    set background=light      " Assume a light background

    if !has('gui')
        if !has('nvim')
            set term=$TERM        " Make arrow and other keys work
        endif

        " Fix start up in REPLACE mode in WSL
        if LINUX()
            set t_u7=
        endif
    endif

    filetype plugin indent on " Automatically detect file types.
    set mouse=a               " Automatically enable mouse usage
    set mousehide             " Hide the mouse cursor while typing
    set guioptions=           " Hide scroll bar in GVim
    scriptencoding utf-8
    set encoding=utf-8

    if has('clipboard')
        if has('unnamedplus')                 " When possible use + register for copy-paste
            set clipboard=unnamed,unnamedplus
        else                                  " On mac and Windows, use * register for copy-paste
            set clipboard=unnamed
        endif
    endif

    set shortmess+=cfilmnrxoOtT                     " Abbrev. of messages (avoids 'hit enter')
    set viewoptions=folds,options,cursor,unix,slash " Better Unix / Windows compatibility
    set virtualedit=onemore                         " Allow for cursor beyond last character
    set history=1000                                " Store a ton of history (default is 20)
    set nospell                                     " Spell checking off
    set hidden                                      " Allow buffer switching without saving
    set iskeyword-=.                                " '.' is an end of word designator
    set iskeyword-=#                                " '#' is an end of word designator
    set iskeyword-=-                                " '-' is an end of word designator

    " Instead of reverting the cursor to the last position in the buffer, we
    " set it to the first line when editing a git commit message
    au! FileType gitcommit au! BufEnter COMMIT_EDITMSG call setpos('.', [0, 1, 1, 0])

    " Setting up the directories
    set backup                      " Backups are nice ...
    if has('persistent_undo')
        set undofile                " So is persistent undo ...
        set undolevels=1000         " Maximum number of changes that can be undone
        set undoreload=10000        " Maximum number lines to save for undo on a buffer reload
    endif

    " Initialize directories
    function! InitializeDirectories()
        let parent = $HOME
        let prefix = 'vim'
        let dir_list = {
                    \ 'backup': 'backupdir',
                    \ 'views': 'viewdir',
                    \ 'swap': 'directory'
                    \ }

        if has('persistent_undo')
            if has('nvim')
                let dir_list['undo/nvim'] = 'undodir'
            else
                let dir_list['undo/vim'] = 'undodir'
            endif
        endif

        " To specify a different directory in which to place the vimbackup,
        " vimviews, vimundo, and vimswap files/directories
        let common_dir = $HOME . '/.vim/tempfiles/' . prefix

        for [dirname, settingname] in items(dir_list)
            let directory = common_dir . dirname . '/'
            if exists("*mkdir")
                if !isdirectory(directory)
                    call mkdir(directory, "p")
                endif
            endif
            if !isdirectory(directory)
                echo "Warning: Unable to create backup directory: " . directory
                echo "Try: mkdir -p " . directory
            else
                let directory = substitute(directory, " ", "\\\\ ", "g")
                exec "set " . settingname . "=" . directory
            endif
        endfor

        if !has('nvim')
            set viminfo+=n$HOME/.vim/tempfiles/viminfo
        endif
    endfunction
    call InitializeDirectories()
" }

" Misc {
    set autoindent                  " Indent at the same level of the previous line
    set backspace=indent,eol,start  " Backspace for dummies
    set breakindent
    set comments=sl:/*,mb:*,elx:*/  " auto format comment blocks
    set cursorline                  " Highlight current line
    set equalalways
    set expandtab                   " Tabs are spaces, not tabs
    set foldenable                  " Auto fold code
    set hlsearch                    " Highlight search terms
    set ignorecase                  " Case insensitive search
    set incsearch                   " Find as you type search
    set linespace=0                 " No extra spaces between rows
    set list
    set listchars=tab:›\ ,trail:•,extends:#,nbsp:. " Highlight problematic whitespaces
    set nobomb
    set nojoinspaces                " Prevents inserting two spaces after punctuation on a join (J)
    set noreadonly
    set noshowmode                  " Disable mode message
    set number relativenumber       " Line numbers on
    set scrolljump=0                " Lines to scroll when cursor leaves screen
    set scrolloff=3                 " Minimum lines to keep above and below cursor
    set shiftwidth=4                " Use indents of 4 spaces
    set showmatch                   " Show matching brackets/parenthesis
    set smartcase                   " Case sensitive when uc present
    set softtabstop=4               " Let backspace delete indent
    set splitbelow                  " Puts new split windows to the bottom of the current
    set splitright                  " Puts new vsplit windows to the right of the current
    set tabpagemax=15               " Only show 15 tabs
    set tabstop=4                   " An indentation every four columns
    set tw=120
    set updatetime=300
    set whichwrap=b,s,h,l,<,>,[,]   " Backspace and cursor keys wrap too
    set wildmenu                    " Show list instead of just completing
    set wildmode=longest:full,full  " Command <Tab> completion, list matches, then longest common part, then all.
    set winminheight=0              " Windows can be 0 line high
    set wrap                        " Wrap long lines

    autocmd! BufRead,BufNewFile *.html.twig set ft=html.twig
    autocmd! BufRead,BufNewFile *.coffee set ft=coffee
    autocmd! BufRead,BufNewFile *.rst set ft=rst
    autocmd! BufRead,BufNewFile *.tex set ft=tex
    autocmd! FileType json set ft=jsonc

    " Crontab {
        if $VIM_CRONTAB == 'true'
            set nobackup
            set nowritebackup
        endif
    " }

    " Wild ignore {
        set wildignore+=.git,.hg,.svn
        set wildignore+=*.aux,*.out,*.toc
        set wildignore+=*.o,*.obj,*.exe,*.dll,*.manifest,*.rbc,*.class
        set wildignore+=*.ai,*.bmp,*.gif,*.ico,*.jpg,*.jpeg,*.png,*.psd,*.webp
        set wildignore+=*.avi,*.divx,*.mp4,*.webm,*.mov,*.m2ts,*.mkv,*.vob,*.mpg,*.mpeg
        set wildignore+=*.mp3,*.oga,*.ogg,*.wav,*.flac,*.m4a,*.mov
        set wildignore+=*.eot,*.otf,*.ttf,*.woff
        set wildignore+=*.doc,*.pdf,*.cbr,*.cbz
        set wildignore+=*.zip,*.tar.gz,*.tar.bz2,*.rar,*.tar.xz,*.kgb
        set wildignore+=*.swp,.lock,.DS_Store,._*
    " }

    " Fix esc delay {
        if ! has('gui_running')
            set ttimeoutlen=0 timeoutlen=500
            augroup FastEscape
                autocmd!
                au InsertEnter * set timeoutlen=0
                au InsertLeave * set timeoutlen=500
            augroup END
        endif
    " }

    " Reload vim settings
    command! Reload source ~/.vim/vimrc


    function! SetHl(name, fg, bg)
        exe 'hi ' . a:name . ' guifg='. a:fg .' guibg=' . a:bg
    endfunction
" }

" Key Mappings {

    let mapleader = ' '

    " Wrapped lines goes down/up to next row, rather than next line in file.
    noremap j gj
    noremap k gk
    noremap $ g$
    noremap 0 g0
    noremap ^ g^

    " Command mode navigation
    cnoremap <C-n> <Down>
    cnoremap <C-p> <Up>
    cnoremap <C-b> <Left>
    cnoremap <C-f> <Right>
    cnoremap <C-a> <Home>

    " Yank from the cursor to the end of the line, to be consistent with C and D.
    nnoremap Y y$

    " Visual shifting (does not exit Visual mode)
    vnoremap < <gv
    vnoremap > >gv

    " Allow using the repeat operator with a visual selection (!)
    vmap . :normal .<CR>

    " For when you forget to sudo.. Really Write the file.
    cmap w!! w !sudo tee % >/dev/null

    map ,,c :python ReformatTable()<CR>
    map ,,f :python ReflowTable()<CR>

    " Shorcut saving
    nmap <leader>w :w<CR>

    " Shortcut deleting buffer
    nmap <leader>x :bd<CR>

    " Compile and run code
    set autowrite
    autocmd! BufEnter,BufNewFile *.vim,*vimrc* nmap <leader>s :w <bar> so % <CR>

    " Terminal mode
    command! Vter vert ter zsh
    command! Ter ter zsh

    " Clear highlight
    nmap <silent> ' :let @/="" <CR>
    nmap <silent> \ :let @/="" <CR>

    " Map redo to U
    nmap U :redo<CR>

    " Switch between .h/.cuh and .cpp/.cu files
    nmap <leader>ch :e %:p:s,.h$,.X123X,:s,.cpp$,.h,:s,.X123X$,.cpp,<CR>
    nmap <leader>cu :e %:p:s,.cuh$,.X123X,:s,.cu$,.cuh,:s,.X123X$,.cu,<CR>

    " Insert mode navigation
    inoremap <C-h> <Left>
    inoremap <C-l> <Right>

    " Clear screen and redraw
    nmap <silent> <C-l>
                \ :nohlsearch<CR>
                \ :diffupdate<CR>
                \ :syntax sync fromstart<CR>
                \ :AirlineRefresh<CR>
                \ :set relativenumber <bar> set number <bar> set cursorline <bar> set signcolumn=yes <CR>

    " Shortcut to copy over ssh
    vmap <silent> sy :w !sshcopy<CR><CR>
" }

" Displays {
    function! GruvBoxSettings()
        let g:gruvbox_invert_selection = 0
        let g:airline_theme = 'gruvbox'

        " Fix term colors
        if has("termguicolors")
            let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
            let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"
            " enable true color
            set termguicolors
        endif

        colo gruvbox

        hi GruvboxGreenSign  guifg=#79740e guibg=bg
        hi GruvboxRedSign    guifg=#9d0006 guibg=bg
        hi GruvboxAquaSign   guifg=#427b58 guibg=bg
        hi GruvboxYellowSign guifg=#b57614 guibg=bg

    endfunction

    syntax on              " Syntax highlighting
    set t_Co=256
    call GruvBoxSettings()
    hi clear SignColumn    " SignColumn should match background
    set conceallevel=1

    " Floating window
    let s:menu_bg = '#f3e5bc'
    call SetHl('Fmenu', '#32302f', s:menu_bg)
    "exe 'hi Fmenu guifg=#32302f guibg=' . s:menu_bg
    hi! def link FmenuSbar PmenuSbar
    call SetHl('FmenuThumb', s:menu_bg, '#8a95a7')
    "exe 'hi FmenuThumb guifg=' . s:menu_bg . ' guibg=#8a95a7'

    " Setup cursor style
    set guicursor=n-v-c-sm:hor20,i-ci-ve:hor20,r-cr-o:hor20
    if exists('$TMUX')
        let &t_SI .= "\<esc>Ptmux;\<esc>\<esc>[4 q\<esc>\\"
        let &t_EI .= "\<esc>Ptmux;\<esc>\<esc>[4 q\<esc>\\"
        let &t_SR .= "\<esc>Ptmux;\<esc>\<esc>[4 q\<esc>\\"
    endif
" }

" Plugin Settings

" Matchit {
    if isdirectory(expand("~/.vim/bundle/matchit.zip"))
        let b:match_ignorecase = 1
    endif
" }

" Vim-rooter {
    if isdirectory(expand("~/.vim/bundle/vim-rooter/"))
        let g:rooter_targets = 'Projects/,Course\ Work/,*'
        let g:rooter_patterns = ['.git/']
        let g:rooter_change_directory_for_non_project_files = 'current'
        let g:rooter_silent_chdir = 1
        let g:rooter_resolve_links = 1
    endif
" }

" defx {
    function! g:MaxLineLength()
        let l:max = 0
        for l:line in range(1, line('$'))
            let l:len = strdisplaywidth(substitute(getline(l:line), '\s\+$', '', ''))
            let l:max = max([l:len + 6, l:max])
        endfor
        return l:max
    endfunction

    if isdirectory(expand("~/.vim/bundle/defx.nvim"))
        call defx#custom#column('icon', {
                    \ 'root_icon': ' ',
                    \ 'directory_icon': '',
                    \ 'opened_icon': '',
                    \ })

        call defx#custom#option('_', {
                    \ 'split': 'vertical',
                    \ 'winwidth': 35,
                    \ 'direction': 'topleft',
                    \ 'columns': 'git:indent:icons:space:filename:mark',
                    \ })

        call defx#custom#column('filename', {
                    \ 'min_width': 40,
                    \ 'max_width': 40,
                    \ })

        call defx#custom#column('mark', {
                    \ 'readonly_icon': 'R',
                    \ 'selected_icon': '✓',
                    \ })

        call defx#custom#column('indent', {
                    \ 'indent': "| ",
                    \ })

        let s:original_width = get(get(defx#custom#_get().option, '_'), 'winwidth')

        " Toggle between defx window width and longest line
        function! g:DefxToggleWidth(context) abort
            let l:max = MaxLineLength()
            let l:new = l:max == winwidth(0) ? s:original_width : l:max
            call defx#call_action('resize', l:new)
        endfunction

        let g:defx_ignore = "*.py[cd],*~,*.swo,*.swp,.git,.hg,.svn,*.bzr,*.DS_Store,
                            \build,gradle,.gradle,.idea,bin,cmake-build*,CMakeCache.txt,
                            \CMakeFiles,.github,.travis,.clangd*"
        nmap <silent><leader>e :Defx -toggle
                    \ -ignored-files=`g:defx_ignore`
                    \ -resume
                    \ -search-recursive=`resolve(expand('%:p'))` `getcwd()` <CR>

        au! FileType defx call s:defx_my_settings()
        function! s:defx_my_settings() abort
            " Define mappings
            nmap <silent><buffer><expr> w       defx#do_action('call', 'DefxToggleWidth')
            nmap <silent><buffer><expr> oo      defx#do_action('multi', ['drop', 'quit'])
            nmap <silent><buffer><expr> o       defx#do_action('drop')
            nmap <silent><buffer><expr> <CR>    defx#is_directory() ?
                                                    \ defx#do_action('open_or_close_tree') :
                                                    \ defx#do_action('drop')
            nmap <silent><buffer><expr> v       defx#do_action('open','vsplit')
            nmap <silent><buffer><expr> vv      defx#do_action('multi', [['drop', 'vsplit'], 'quit'])
            nmap <silent><buffer><expr> h       defx#do_action('cd',['..'])
            nmap <silent><buffer><expr> l       defx#do_action('open_directory')
            nmap <silent><buffer><expr> y       defx#do_action('copy')
            nmap <silent><buffer><expr> m       defx#do_action('move')
            nmap <silent><buffer><expr> p       defx#do_action('paste')
            nmap <silent><buffer><expr> aa      defx#do_action('new_directory')
            nmap <silent><buffer><expr> a       defx#do_action('new_file')
            nmap <silent><buffer><expr> S       defx#do_action('toggle_sort','time')
            nmap <silent><buffer><expr> d       defx#do_action('remove')
            nmap <silent><buffer><expr> r       defx#do_action('rename')
            nmap <silent><buffer><expr> f       defx#do_action('search')
            nmap <silent><buffer><expr> !       defx#do_action('execute_command')
            nmap <silent><buffer><expr> x       defx#do_action('execute_system')
            nmap <silent><buffer><expr> yy      defx#do_action('yank_path')
            nmap <silent><buffer><expr> .       defx#do_action('toggle_ignored_files')
            nmap <silent><buffer><expr> ;       defx#do_action('repeat')
            nmap <silent><buffer><expr> q       defx#do_action('quit')
            nmap <silent><buffer><expr> j       line('.') == line('$') ? 'gg' : 'j'
            nmap <silent><buffer><expr> k       line('.') == 1 ? 'G' : 'k'
            nmap <silent><buffer><expr> <C-l>   defx#do_action('redraw')
            nmap <silent><buffer><expr> <C-g>   defx#do_action('print')
            nmap <silent><buffer><expr> cd      defx#do_action('change_vim_cwd')
            nmap <silent><buffer><expr> <TAB>   defx#do_action('toggle_select')
        endfunction

    endif
" }

" defx-git {
    if isdirectory(expand("~/.vim/bundle/defx-git"))
        hi! def link Defx_git_0_Untracked Comment
        hi! def link Defx_git_0_Ignored DiffAdd
        hi! def link Defx_git_0_Renamed Title
        hi! def link Defx_git_0_Modified Special
        hi! def link Defx_git_0_Unmerged Label
        hi! def link Defx_git_0_Deleted DiffDelete
        hi! def link Defx_git_0_Staged Function
    endif
" }

" defx-icons {
    if isdirectory(expand("~/.vim/bundle/defx-icons"))
        let g:defx_icons_enable_syntax_highlight = 1
        let g:defx_icons_column_length = 1
        let g:defx_icons_directory_icon = ''
        let g:defx_icons_mark_icon = '*'
        let g:defx_icons_parent_icon = ''
        let g:defx_icons_default_icon = ''
        let g:defx_icons_directory_symlink_icon = ''
        " Options below are applicable only when using 'tree' feature
        let g:defx_icons_root_opened_tree_icon = ''
        let g:defx_icons_nested_opened_tree_icon = ''
        let g:defx_icons_nested_closed_tree_icon = ''

        " Colors
        let g:defx_icons_gui_colors = {
                    \ 'default': '#504945'
                    \ }
        let g:defx_icons_term_colors = {
                    \ 'default': 239
                    \}
        hi! link Directory GruvboxAqua
    endif
" }

" Session List {
    set sessionoptions=blank,buffers,curdir,folds,tabpages,winsize
    if isdirectory(expand("~/.vim/bundle/sessionman.vim/"))
        nmap <leader>sl :SessionList<CR>
        nmap <leader>ss :SessionSave<CR>
        nmap <leader>sc :SessionClose<CR>
    endif
" }

" TagBar {
    if isdirectory(expand("~/.vim/bundle/tagbar/"))
        nmap <silent> <leader>tt :TagbarToggle<CR>
    endif
"}

" Rainbow {
            "\ 'ctermfgs': ['lightblue', 229, 'lightcyan', 'lightmagenta'],
    if isdirectory(expand("~/.vim/bundle/rainbow/"))
        let g:rainbow_conf = {
            \ 'guifgs': ['royalblue3', 'darkorange4', 'seagreen4', 'firebrick'],
            \ 'ctermfgs': ['darkblue', 'darkyellow', 'darkgreen', 'darkred'],
            \ 'operators': '_,_',
            \ 'parentheses': ['start=/(/ end=/)/ fold',
            \                 'start=/\[/ end=/\]/ fold',
            \                 'start=/{/ end=/}/ fold'],
            \ 'separately': {
            \     '*': {},
            \     'tex': {
            \         'parentheses': [['(',')'], ['\[','\]'], ['\\begin{.*}','\\end{.*}']],
            \     },
            \     'lisp': {
            \         'guifgs': ['royalblue', 'darkorange', 'seagreen', 'firebrick', 'darkorchid'],
            \     },
            \     'vim': {
            \         'parentheses': ['start=/(/ end=/)/',
            \                         'start=/\[/ end=/\]/',
            \                         'start=/{/ end=/}/ fold',
            \                         'start=/(/ end=/)/ containedin=vimFuncBody',
            \                         'start=/\[/ end=/\]/ containedin=vimFuncBody',
            \                         'start=/{/ end=/}/ fold containedin=vimFuncBody'],
            \     },
            \     'html': {
            \         'parentheses': ['start=/\v\<((area|base|br|col|embed|hr|img|input|keygen
                                            \|link|menuitem|meta|param|source|track|wbr)[ >])
                                            \@!\z([-_:a-zA-Z0-9]+)(\s+[-_:a-zA-Z0-9]+(\=
                                            \("[^"]*"|'."'".'[^'."'".']*'."'".'|[^ '."'".'"><=`]*)
                                            \)?)*\>/ end=#</\z1># fold'],
            \     },
            \     'css': 0,
            \ },
        \ }
        let g:rainbow_active = 1 "0 if you want to enable it later via :RainbowToggle
    endif
"}

" Airline {
    " Use the powerline theme and optionally enable powerline symbols.
    " To use the symbols , , , , , , and .in the statusline

    if isdirectory(expand("~/.vim/bundle/vim-airline"))
        let g:airline_theme = 'gruvbox'

        let g:airline_highlighting_cache = 0
        let g:airline_powerline_fonts = 0
        let g:bufferline_echo = 0
        let g:airline_detect_spell = 0

        " extensions
        let g:airline#extensions#bufferline#enabled = 0
        let g:airline#extensions#tabline#fnamemod = ':t'
        let g:airline#extensions#tabline#left_alt_sep = '|'
        let g:airline#extensions#branch#enabled = 1
        let g:airline#extensions#branch#format = 2
        let g:airline#extensions#tagbar#enabled = 1
        let g:airline#extensions#whitespace#mixed_indent_algo = 2
        let g:airline#extensions#ale#enabled = 1
        let g:airline#extensions#coc#enabled = 1

        " Unicode symbols
        if !exists('g:airline_symbols')
            let g:airline_symbols = {}
        endif
        let g:Powerline_symbols = 'unicode'
        let g:Powerline_symbols = 'fancy'
        let g:airline_symbols.crypt = '🔒'
        let g:airline_symbols.branch = ''
        let g:airline_symbols.paste = '∥'
        let g:airline_symbols.notexists = '∄'
        let g:airline_symbols.whitespace = 'Ξ'
        let g:airline_symbols.space = "\ua0"
        let g:airline_symbols.linenr = ""
        let g:airline_symbols.colnr = ""

        " Sections
        let g:airline_section_x = airline#section#create_right(['tagbar'])
        let g:airline_section_y = airline#section#create(['filetype'])
        let g:airline_section_z = '%3p%% %{g:airline_symbols.linenr}%l/%L %{g:airline_symbols.colnr}%c'

        " Configure tabline
        let g:airline#extensions#tabline#enabled = 1
        let g:airline#extensions#tabline#buffer_idx_mode = 1
        nmap <leader>1 <Plug>AirlineSelectTab1
        nmap <leader>2 <Plug>AirlineSelectTab2
        nmap <leader>3 <Plug>AirlineSelectTab3
        nmap <leader>4 <Plug>AirlineSelectTab4
        nmap <leader>5 <Plug>AirlineSelectTab5
        nmap <leader>6 <Plug>AirlineSelectTab6
        nmap <leader>7 <Plug>AirlineSelectTab7
        nmap <leader>8 <Plug>AirlineSelectTab8
        nmap <leader>9 <Plug>AirlineSelectTab9
        nmap <silent> – <Plug>AirlineSelectPrevTab
        nmap <silent> ≠ <Plug>AirlineSelectNextTab
        if LINUX() || has('nvim')
            nmap <silent> <A--> <Plug>AirlineSelectPrevTab
            nmap <silent> <A-=> <Plug>AirlineSelectNextTab
        endif
    endif
" }

" ALE {
    if isdirectory(expand("~/.vim/bundle/ale/"))
        let g:ale_disable_lsp = 1
        let g:ale_linters_explicit = 1
        let g:ale_lint_on_text_changed = 'normal'
        let g:ale_lint_delay = 0
        let g:ale_echo_delay = 0
        let g:ale_set_loclist = 0
        let g:ale_set_quickfix = 0
        let g:ale_sign_error = '✗'
        let g:ale_sign_warning = '▲'
        let g:ale_sign_info = '●'
        let g:ale_floating_preview = 1
        let g:ale_floating_window_border = ['│', '─', '╭', '╮', '╯', '╰']
        "let g:ale_floating_window_border = []
        if g:colors_name == 'gruvbox'
            hi! link ALEErrorSign GruvboxRedSign
            hi! link ALEWarningSign GruvboxYellowSign
            hi! link ALEInfoSign GruvboxAquaSign
        endif
        let g:ale_statusline_format = ['✗ %d', '▲ %d', '✓ OK']

        let g:ale_linters = { }

        let g:ale_fixers = { '*': ['remove_trailing_lines', 'trim_whitespace'] }
        let g:ale_fix_on_save = 1

        if g:ale_completion_enabled == 1
            nmap <silent> <leader>dl :ALEGoToDefinition <CR>
            nmap <silent> <leader>re :ALEFindReferences <CR>
            nmap <silent> <leader>fi :ALEFix<CR>

            set omnifunc=ale#completion#OmniFunc
            nmap <silent> <C-k> <Plug>(ale_previous_wrap)
            nmap <silent> <C-j> <Plug>(ale_next_wrap)
        endif
    endif
" }

" FastFold {
    if isdirectory(expand("~/.vim/bundle/FastFold/"))
        let g:tex_fold_enabled=1
        let g:fastfold_fold_command_suffixes = []
        nmap zuz <Plug>(FastFoldUpdate)
    endif
" }

" IndentLine {
    if isdirectory(expand("~/.vim/bundle/indentLine/")) || isdirectory(expand("~/.vim/bundle/indent-blankline.nvim"))
        let g:indentLine_enabled = 1
        let g:indentLine_faster = 0
        let g:indentLine_char = '│'    " Can be ¦, ┆, │, ⎸, or ▏
        let g:indentLine_fileTypeExclude = ['text', 'defx']
        let g:indentLine_bufTypeExclude = ['help', 'terminal']
        let g:indentLine_bufNameExclude = ['_.*', 'startify', 'NERD_tree.*']
        let g:indentLine_concealcursor = 'inc'
    endif
" }

" Startify {
    if isdirectory(expand("~/.vim/bundle/vim-startify/"))
        let g:startify_custom_header = [
                        \'                                                                    ',
                        \'                                                                    ',
                        \'           ___   ___  ____  ___   ___                               ',
                        \'          |   | |   ||    ||   | |   |                              ',
                        \'          |   | |   ||    ||   |_|   |                              ',
                        \'          |   |_|   ||    ||         |                              ',
                        \'          |         ||    ||         |                              ',
                        \'           |       | |    ||  ||_||  |                              ',
                        \'            |     |  |    ||  |   |  |                              ',
                        \'             |___|   |____||__|   |__|  version ' . v:version . ' ',
                        \'                                                                    ',
                        \'                                                                    ',
                        \ ]
        let g:startify_session_dir = $HOME .  '/.vim/' . '/sessions'
        let g:startify_files_number = 6
        let g:startify_list_order = [
                    \ ['   MRU files in the current directory:'],
                    \ 'dir',
                    \ ['   MRU files:'],
                    \ 'files',
                    \ ['   Sessions:'],
                    \ 'sessions',
                    \ ['   Bookmarks:'],
                    \ 'bookmarks',
                    \ ]
        let g:startify_bookmarks = [ {'c': '~/.vim/vimrc'},
                                   \ {'cc': '~/.vim/vimrc.bundles'},
                                   \ {'n': '~/.config/nvim/init.vim'},
                                   \ {'i': '~/.dotfiles/init'},
                                   \ ]
        let g:startify_update_oldfiles = 1
        let g:startify_disable_at_vimenter = 0
        let g:startify_session_autoload = 1
        let g:startify_session_persistence = 1
        "let g:startify_session_delete_buffers = 0
        let g:startify_change_to_dir = 0
        let g:startify_skiplist = [
            \ 'COMMIT_EDITMSG',
            \ escape(fnamemodify(resolve($VIMRUNTIME), ':p'), '\') .'doc',
            \ 'bundle/.*/doc',
            \ ]
        autocmd! FileType startify nnoremap <buffer> <F2> <Nop>
        autocmd! FileType startify setl nowrap
    endif
" }

" vim-tmux-navigator {
    let g:tmux_navigator_no_mappings = 1
    let g:tmux_navigator_disable_when_zoomed = 1

    nmap <silent> ˙ :TmuxNavigateLeft<cr>
    nmap <silent> ∆ :TmuxNavigateDown<cr>
    nmap <silent> ˚ :TmuxNavigateUp<cr>
    nmap <silent> ¬ :TmuxNavigateRight<cr>
    nmap <silent> « :TmuxNavigatePrevious<cr>
" }

" Completion {
    " Tab completion
    inoremap <expr> <Tab>   pumvisible() ? "\<C-n>" : "\<Tab>"
    inoremap <expr> <S-Tab> pumvisible() ? "\<C-p>" : "\<S-Tab>"

    " Some convenient mappings
    inoremap <expr> <CR>   pumvisible() ? "\<C-y>" : "\<C-g>u\<CR>"
    inoremap <expr> <Down> pumvisible() ? "\<C-n>" : "\<Down>"
    inoremap <expr> <Up>   pumvisible() ? "\<C-p>" : "\<Up>"
    inoremap <expr> <C-d>  pumvisible() ? "\<PageDown>\<C-p>\<C-n>" : "\<C-d>"
    inoremap <expr> <C-u>  pumvisible() ? "\<PageUp>\<C-p>\<C-n>" : "\<C-u>"

    au! CompleteDone,CursorMovedI,InsertLeave * if pumvisible() == 0|silent! pclose|endif

    set completeopt=menu,longest

    " coc-nvim {
        if isdirectory(expand("~/.vim/bundle/coc.nvim/"))
            let g:ale_lint_on_text_changed = 'never'
            let g:coc_config_home = $HOME . '/.vim'
            let g:coc_global_extensions=[
                        \'coc-pairs',
                        \'coc-snippets',
                        \'coc-lists',
                        \'coc-json'
                        \]
            set signcolumn=yes

            function! s:show_documentation()
                if (index(['vim','help'], &filetype) >= 0)
                    execute 'h '.expand('<cword>')
                else
                    call CocAction('doHover')
                endif
            endfunction

            " Key mappings
            inoremap <silent><expr> <CR> coc#pum#visible() ? coc#pum#confirm() : "\<C-g>u\<CR>"
            inoremap <silent><expr> <Tab> coc#pum#visible() ? coc#pum#next(1) : "\<Tab>"
            inoremap <silent><expr> <S-Tab> coc#pum#visible()) ? coc#pum#prev(1) : "\<S-Tab>"
            inoremap <silent><expr> <down> coc#pum#visible() ? coc#pum#next(0) : "\<down>"
            inoremap <silent><expr> <up> coc#pum#visible() ? coc#pum#prev(0) : "\<up>"
            nmap <silent> <leader>dl <Plug>(coc-definition)
            nmap <silent> <leader>re <Plug>(coc-references)
            nmap <silent> <leader>fi <Plug>(coc-fix-current)
            xmap <silent> <leader>fo <Plug>(coc-format-selected)
            nmap <silent> <leader>dd <Plug>(coc-diagnostic-info)
            nmap <silent> <Leader>im <Plug>(coc-implementation)
            nmap <silent> <C-j>      <Plug>(coc-diagnostic-next)
            nmap <silent> <C-k>      <Plug>(coc-diagnostic-prev)
            nmap <leader>rn <Plug>(coc-rename)
            nmap <leader>ra <Plug>(coc-refactor)
            nmap <silent> <leader>fo :call CocAction('format') <CR>
            nmap <silent> <leader>rs :CocRestart <CR><CR>
            nmap <silent> <leader>ho :call <SID>show_documentation() <CR>
            nmap <silent> <leader>da :<C-u>CocList diagnostics<cr>
            nmap <silent> <leader>b<space> :CocList buffers<CR>

            " Highlight groups
            hi! def link CocErrorSign GruvboxRedSign
            hi! def link CocWarningSign GruvboxYellowSign
            hi! def link CocInfoSign GruvboxAquaSign
            hi! def link CocHintSign CocWarningSign

            hi! def link CocFloating Fmenu
            exe 'hi CocErrorFloat   guifg=#9d0006 guibg=' . s:menu_bg
            exe 'hi CocWarningFloat guifg=#b57614 guibg=' . s:menu_bg
            exe 'hi CocInfoFloat    guifg=#427b58 guibg=' . s:menu_bg
            hi! def link CocHintFloat CocWarningFloat
            hi! CocMenuSel guifg=#f3e5bc guibg=#076678

            "" Autocmd
            augroup coc_user_defined
                autocmd!
                autocmd BufEnter *.cs silent :ALEDisableBuffer
                autocmd FileType cs command! ClearBin exe "!find . -name bin -exec rm -rf {} +"
                autocmd FileType cs nmap <silent> <leader>rs :CocRestart <CR><CR>
                autocmd CursorHold  *.cs silent call CocActionAsync('highlight')
                autocmd CursorHoldI *.cs silent call CocActionAsync('showSignatureHelp')
                autocmd User CocJumpPlaceholder call CocActionAsync('showSignatureHelp')
                autocmd FileType tex let b:coc_pairs = [["$", "$"]]
            augroup END
        endif
    " }
" }

" echodoc {
    let g:echodoc#enable_at_startup = 0
    if isdirectory(expand("~/.vim/bundle/echodoc.vim")) && g:echodoc#enable_at_startup == 1
        let g:echodoc#type = "floating"
        hi! link EchoDocFloat Pmenu
    endif
" }

" FZF {
    if executable("fzf")
        set rtp+=~/.fzf

        let g:fzf_layout = {
                    \ 'down': '~30%',
                    \ }
        let g:fzf_colors =
                    \ { 'fg':    ['fg', 'Normal'],
                    \ 'bg':      ['bg', 'Normal'],
                    \ 'hl':      ['fg', 'Comment'],
                    \ 'fg+':     ['fg', 'CursorLine', 'CursorColumn', 'Normal'],
                    \ 'bg+':     ['bg', 'CursorLine', 'CursorColumn'],
                    \ 'hl+':     ['fg', 'Statement'],
                    \ 'info':    ['fg', 'PreProc'],
                    \ 'border':  ['fg', 'Ignore'],
                    \ 'prompt':  ['fg', 'Conditional'],
                    \ 'pointer': ['fg', 'Exception'],
                    \ 'marker':  ['fg', 'Keyword'],
                    \ 'spinner': ['fg', 'Label'],
                    \ 'header':  ['fg', 'Comment'] }

        command! -bang -nargs=* Ag call fzf#vim#ag
                    \ (
                    \ <q-args>,
                    \ '--color-path "0;34" --color-line-number "0;35" --color-match "1;33"',
                    \ { 'options': ['--color', 'hl:#9d0006,hl+:#9d0006'] },
                    \ <bang>0
                    \ )

        " key mappings
        nmap <silent> <leader>f<space> :FZF <CR>
        nmap <silent> <leader>r<space> :History <CR>
        nmap <silent> <leader>ff :BTags <CR>
        nmap <silent> <leader>l<space> :Lines <CR>
        " Bind K to grep word under cursor
        nmap <silent> K :call fzf#vim#ag
                    \ (
                    \ expand('<cword>'),
                    \ '--color-path "0;34" --color-line-number "0;35" --color-match "1;33"',
                    \ { 'options': ['--color', 'hl:#9d0006,hl+:#9d0006'] },
                    \ ) <CR>
    endif
" }

" cpp enhanced highlight {
    if isdirectory(expand("~/.vim/bundle/vim-cpp-enhanced-highlight"))
        hi! def link Function GruvboxBlueBold
        hi! def link Identifier GruvboxFg2
        let g:cpp_class_scope_highlight = 0
        let g:cpp_member_variable_highlight = 1
        let g:cpp_class_decl_highlight = 0
        let g:cpp_experimental_template_highlight = 1
        let g:cpp_concepts_highlight = 1
    endif
" }

" CtrlSF {
    if isdirectory(expand("~/.vim/bundle/ctrlsf.vim"))
        let g:ctrlsf_auto_focus = {"at": "start"}
        let g:ctrlsf_position = 'bottom'
        let g:ctrlsf_winsize = '40%'
        let g:ctrlsf_confirm_save = 0
        nmap SF <Plug>CtrlSFPrompt
        vmap SF <Plug>CtrlSFVwordExec
    endif
" }

" litecorrect {
    if isdirectory(expand("~/.vim/bundle/vim-litecorrect"))
        augroup litecorrect
            autocmd!
            autocmd FileType markdown,mkd,tex call litecorrect#init()
        augroup END
    endif
" }

" NERD Commenter {
    if isdirectory(expand("~/.vim/bundle/nerdcommenter"))
        let g:NERDCustomDelimiters = { 'razor': {'left': '@* ', 'right': ' *@'}}
        let g:NERDDefaultAlign = 'none'
    endif
" }
