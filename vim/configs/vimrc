" vim: set sw=4 ts=4 sts=4 et foldmarker={,} foldlevel=0 foldmethod=marker:

" Environment {

    " Identify platform {
        silent function! OSX()
            return has('macunix')
        endfunction
        silent function! LINUX()
            return has('unix') && !has('macunix') && !has('win32unix')
        endfunction
    " }

    " Basics {
        set nocompatible        " Must be first line
    " }

    " Arrow Key Fix {
        if &term[:4] == "xterm" || &term[:5] == 'screen' || &term[:3] == 'rxvt'
            inoremap <silent> <C-[>OC <RIGHT>
        endif
    " }

" }

" Plugin setteings before loading {
    let g:ale_completion_enabled = 0
    "let g:ale_set_balloons = 1
    "let g:ale_completion_delay = 0
" }

" Use bundles config {
    if filereadable(expand("~/.vim/vimrc.bundles"))
        source ~/.vim/vimrc.bundles
    endif
" }

" General {
    set background=light      " Assume a light background

     if !has('gui')
        set term=$TERM        " Make arrow and other keys work
     endif
    filetype plugin indent on " Automatically detect file types.
    syntax on                 " Syntax highlighting
    set mouse=a               " Automatically enable mouse usage
    set mousehide             " Hide the mouse cursor while typing
    set guioptions=           " Hide scroll bar in GVim
    scriptencoding utf-8

    if has('clipboard')
        if has('unnamedplus')                 " When possible use + register for copy-paste
            set clipboard=unnamed,unnamedplus
        "else                                  " On mac and Windows, use * register for copy-paste
            "set clipboard=unnamed
        endif
    endif

    set shortmess+=cfilmnrxoOtT                     " Abbrev. of messages (avoids 'hit enter')
    set viewoptions=folds,options,cursor,unix,slash " Better Unix / Windows compatibility
    set virtualedit=onemore                         " Allow for cursor beyond last character
    set history=1000                                " Store a ton of history (default is 20)
    set nospell                                     " Spell checking off
    set hidden                                      " Allow buffer switching without saving
    set iskeyword-=.                                " '.' is an end of word designator
    set iskeyword-=#                                " '#' is an end of word designator
    set iskeyword-=-                                " '-' is an end of word designator

    " Instead of reverting the cursor to the last position in the buffer, we
    " set it to the first line when editing a git commit message
    au! FileType gitcommit au! BufEnter COMMIT_EDITMSG call setpos('.', [0, 1, 1, 0])

    " Restore cursor to file position in previous editing session
    function! ResCur()
        if line("'\"") <= line("$")
            silent! normal! g`"
            return 1
        endif
    endfunction

    augroup resCur
        autocmd! BufWinEnter * call ResCur()
    augroup END

    " Setting up the directories
    set backup                      " Backups are nice ...
    if has('persistent_undo')
        set undofile                " So is persistent undo ...
        set undolevels=1000         " Maximum number of changes that can be undone
        set undoreload=10000        " Maximum number lines to save for undo on a buffer reload
    endif

    " Initialize directories
    function! InitializeDirectories()
        let parent = $HOME
        let prefix = 'vim'
        let dir_list = {
                    \ 'backup': 'backupdir',
                    \ 'views': 'viewdir',
                    \ 'swap': 'directory' }

        if has('persistent_undo')
            let dir_list['undo'] = 'undodir'
        endif

        " To specify a different directory in which to place the vimbackup,
        " vimviews, vimundo, and vimswap files/directories
        let common_dir = $HOME . '/.vim/tempfiles/' . prefix

        for [dirname, settingname] in items(dir_list)
            let directory = common_dir . dirname . '/'
            if exists("*mkdir")
                if !isdirectory(directory)
                    call mkdir(directory)
                endif
            endif
            if !isdirectory(directory)
                echo "Warning: Unable to create backup directory: " . directory
                echo "Try: mkdir -p " . directory
            else
                let directory = substitute(directory, " ", "\\\\ ", "g")
                exec "set " . settingname . "=" . directory
            endif
        endfor

        set viminfo='100,n$HOME/.vim/tempfiles/viminfo
    endfunction
    call InitializeDirectories()
" }

" Misc {
    set wrap                        " Wrap long lines
    set autoindent                  " Indent at the same level of the previous line
    set shiftwidth=4                " Use indents of 4 spaces
    set expandtab                   " Tabs are spaces, not tabs
    set tabstop=4                   " An indentation every four columns
    set softtabstop=4               " Let backspace delete indent
    set nojoinspaces                " Prevents inserting two spaces after punctuation on a join (J)
    set splitright                  " Puts new vsplit windows to the right of the current
    set splitbelow                  " Puts new split windows to the bottom of the current
    set breakindent
    set equalalways
    set tw=120
    set updatetime=300

    set comments=sl:/*,mb:*,elx:*/  " auto format comment blocks

    autocmd! BufNewFile,BufRead *.html.twig set filetype=html.twig
    autocmd! BufNewFile,BufRead *.coffee set filetype=coffee
    autocmd! BufRead,BufNewFile *.rst set ft=rst
    autocmd! BufRead,BufNewFile *.go set nospell

    "nnoremap <silent> <C-z> @=(foldlevel('.')?'za':"\<Space>")<CR>
    vnoremap <C-z> zf

    " Crontab {
        if $VIM_CRONTAB == 'true'
            set nobackup
            set nowritebackup
        endif
    " }

    " Wild ignore {
        set wildignore+=.git,.hg,.svn
        set wildignore+=*.aux,*.out,*.toc
        set wildignore+=*.o,*.obj,*.exe,*.dll,*.manifest,*.rbc,*.class
        set wildignore+=*.ai,*.bmp,*.gif,*.ico,*.jpg,*.jpeg,*.png,*.psd,*.webp
        set wildignore+=*.avi,*.divx,*.mp4,*.webm,*.mov,*.m2ts,*.mkv,*.vob,*.mpg,*.mpeg
        set wildignore+=*.mp3,*.oga,*.ogg,*.wav,*.flac,*.m4a,*.mov
        set wildignore+=*.eot,*.otf,*.ttf,*.woff
        set wildignore+=*.doc,*.pdf,*.cbr,*.cbz
        set wildignore+=*.zip,*.tar.gz,*.tar.bz2,*.rar,*.tar.xz,*.kgb
        set wildignore+=*.swp,.lock,.DS_Store,._*
    " }

    " Rsync project {
        function! Sync()
           "!rsync -azcuv -e "ssh -p99" --delete `pwd`/src volta:~/BIIOTA &&
           "\ rsync -azcuv -e "ssh -p99" --delete `pwd`/src pascal:~/BIIOTA &&
           "\ rsync -azcuv -e "ssh -p99" --delete `pwd`/src pascal:~/BIIOTA_2 &&
           "\ rsync -azcuv -e "ssh -p22" --delete `pwd`/src ali2:~/biiota &&
           "\ rsync -azcuv -e "ssh -p22" --delete `pwd`/src aliyun:~/qdu/BIIOTA &&
           "\ rsync -azcuv -e "ssh -p99" --delete `pwd`/src maxwell:~/BIIOTA &&

           !rsync -azcuv -e "ssh -p99" --delete `pwd`/{CMakeLists.txt,src,test,cmake,config.toml} pascal:~/epic &&
        endfunction
    " }

    " Fix esc delay
    if ! has('gui_running')
        set ttimeoutlen=0 timeoutlen=500
        augroup FastEscape
            autocmd!
            au InsertEnter * set timeoutlen=0
            au InsertLeave * set timeoutlen=1000
        augroup END
    endif
" }

" Key Mappings {

    let mapleader = ' '

    " Wrapped lines goes down/up to next row, rather than next line in file.
    noremap j gj
    noremap k gk
    noremap $ g$
    noremap 0 g0
    noremap ^ g^

    " Stupid shift key fixes
    command! -bang -nargs=* -complete=file E e<bang> <args>
    command! -bang -nargs=* -complete=file W w<bang> <args>
    command! -bang -nargs=* -complete=file Wq wq<bang> <args>
    command! -bang -nargs=* -complete=file WQ wq<bang> <args>
    command! -bang Wa wa<bang>
    command! -bang WA wa<bang>
    command! -bang Q q<bang>
    command! -bang QA qa<bang>
    command! -bang Qa qa<bang>

    " Command mode navigation
    cnoremap <C-n> <Down>
    cnoremap <C-p> <Up>
    cnoremap <C-b> <Left>
    cnoremap <C-f> <Right>
    cnoremap <C-a> <Home>

    " Yank from the cursor to the end of the line, to be consistent with C and D.
    nnoremap Y y$

    " Visual shifting (does not exit Visual mode)
    vnoremap < <gv
    vnoremap > >gv

    " Allow using the repeat operator with a visual selection (!)
    vnoremap . :normal .<CR>

    " For when you forget to sudo.. Really Write the file.
    cmap w!! w !sudo tee % >/dev/null

    command! Uf set foldlevel=20

    "nnoremap <f5> :CycleColorNext<CR> " \| Silent call AirlineRefresh()
    "nnoremap <f6> :CycleColorPrev<CR> " \| Silent call AirlineRefresh()

    map ,,c :python ReformatTable()<CR>
    map ,,f :python ReflowTable()<CR>

    " Shorcut saving
    nnoremap <leader>w :w<CR>

    " Compile and run code
    set autowrite
    autocmd! BufEnter,BufNewFile *.cpp nnoremap <leader>s :w <bar> AsyncRun g++ -W -Wall -pedantic -o %:r % && ./%:r<CR>
    autocmd! BufEnter,BufNewFile *.c nnoremap <leader>s :w <bar> AsyncRun gcc -std=c99 -lm % -o %:p:h/%:t:r.out && ./%:r.out<CR>
    autocmd! BufEnter,BufNewFile *.java nnoremap <leader>s :w <bar> AsyncRun gradle build <CR>
    autocmd! BufEnter,BufNewFile *.py nnoremap <leader>s :w <bar> AsyncRun python % <CR>
    autocmd! BufEnter,BufNewFile *.vim,*vimrc* nnoremap <leader>s :w <bar> so % <CR>

    " Terminal mode
    command! Vter vert ter zsh
    command! Ter ter zsh

    " Clear highlight
    nnoremap <silent> ' :let @/="" <CR>
    nnoremap <silent> \ :let @/="" <CR>

    " Map redo to U
    nnoremap U :redo<CR>

    "Search pattern with start of words
    "nnoremap / /\v

    " Switch between .h and .cpp files
    nnoremap <leader>ch :e %:p:s,.h$,.X123X,:s,.cpp$,.h,:s,.X123X$,.cpp,<CR>

    " Insert mode navigation
    inoremap <C-h> <Left>
    inoremap <C-l> <Right>

    " Clear screen and redraw
    nnoremap <silent> <C-l> :nohlsearch<CR>:diffupdate<CR>:syntax sync fromstart<CR>
" }

" Displays {
    function! GruvBoxSettings()
        let g:gruvbox_invert_selection = 0
        let g:airline_theme = 'gruvbox'

        " Fix term colors
        if has("termguicolors")
            let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
            let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"
            " enable true color
            set termguicolors
        endif

        colo gruvbox

        hi GruvboxGreenSign  guifg=#79740e guibg=bg ctermbg=NONE ctermfg=100
        hi GruvboxRedSign    guifg=#9d0006 guibg=bg ctermbg=NONE ctermfg=88
        hi GruvboxAquaSign   guifg=#427b58 guibg=bg ctermbg=NONE ctermfg=66
        hi GruvboxYellowSign guifg=#b57614 guibg=bg ctermbg=NONE ctermfg=136

        hi! def link Function GruvboxBlue
    endfunction

    function! SetDefaultDisplays()
        "let g:indentLine_color_gui = '#4c4c4b'
        if has('gui_macvim')
            "set lines=66 columns=120
            set guifont=Monaco\ Nerd\ Font:h13
        else
            set t_Co=256
        endif
        call GruvBoxSettings()
        highlight clear SignColumn      " SignColumn should match background
        set conceallevel=1
        let b:AutoPairs = {'(':')', '[':']', '{':'}',"'":"'",'"':'"', '`':'`'}
    endfunction

    "function! SetTexDisplays()
        "set background=light
        "colo solarized
        "set guifont=Cousine\ for\ Powerline:h14
        "let g:airline_theme = 'solarized'
        "let b:AutoPairs = {'(':')', '[':']', '{':'}',"'":"'",'"':'"', '`':'`', '$':'$'}
        "set conceallevel=0
    "endfunction

    "function! SetDisplays()
        "if (&ft=='tex')
            "call SetTexDisplays()
        "else
            "call SetDefaultDisplays()
        "endif
        "AirlineRefresh
    "endfunction

    "au! BufEnter,BufRead * call SetDisplays()
    call SetDefaultDisplays()

    set tabpagemax=15               " Only show 15 tabs
    set cursorline                  " Highlight current line
    set backspace=indent,eol,start  " Backspace for dummies
    set linespace=0                 " No extra spaces between rows
    set number relativenumber       " Line numbers on
    set showmatch                   " Show matching brackets/parenthesis
    set incsearch                   " Find as you type search
    set hlsearch                    " Highlight search terms
    set winminheight=0              " Windows can be 0 line high
    set ignorecase                  " Case insensitive search
    set smartcase                   " Case sensitive when uc present
    set wildmenu                    " Show list instead of just completing
    set wildmode=list:longest,full  " Command <Tab> completion, list matches, then longest common part, then all.
    set whichwrap=b,s,h,l,<,>,[,]   " Backspace and cursor keys wraep too
    set scrolljump=0                " Lines to scroll when cursor leaves screen
    set scrolloff=3                 " Minimum lines to keep above and below cursor
    set foldenable                  " Auto fold code
    set list
    set listchars=tab:›\ ,trail:•,extends:#,nbsp:. " Highlight problematic whitespaces
    set lazyredraw                  " Speed up scrolling with large files
    set ttyfast                     " Send more characters to the screen for redrawing
    set noshowmode                  " Disable mode message
" }

" Plugins {

    " GoLang {
        if isdirectory(expand("~/.vim/bundle/vim-go/"))
            let g:go_version_warning = 0
            let g:go_highlight_functions = 1
            let g:go_highlight_methods = 1
            let g:go_highlight_structs = 1
            let g:go_highlight_operators = 1
            let g:go_highlight_build_constraints = 1
            let g:go_fmt_command = "goimports"
            let g:syntastic_go_checkers = ['golint', 'govet', 'errcheck']
            let g:syntastic_mode_map = { 'mode': 'active', 'passive_filetypes': ['go'] }
            au FileType go nmap <Leader>s <Plug>(go-implements)
            au FileType go nmap <Leader>i <Plug>(go-info)
            au FileType go nmap <Leader>e <Plug>(go-rename)
            au FileType go nmap <leader>r <Plug>(go-run)
            au FileType go nmap <leader>b <Plug>(go-build)
            au FileType go nmap <leader>t <Plug>(go-test)
            au FileType go nmap <Leader>gd <Plug>(go-doc)
            au FileType go nmap <Leader>gv <Plug>(go-doc-vertical)
            au FileType go nmap <leader>co <Plug>(go-coverage)
        endif
    " }

    " Matchit {
        if isdirectory(expand("~/.vim/bundle/matchit.zip"))
            let b:match_ignorecase = 1
        endif
    " }

    " Ctags {
        " Automatically generate tag files on save
        "command! Gtags silent !ctags -R -o $HOME/.cache/tags $(pwd) &
        "let g:auctaglangs = ['go']

        "autocmd! BufWritePost <buffer>
            "\ if &buftype != 'terminal' |
                "\ if index(g:auctaglangs, &ft) > -1 |
                    "\ exe 'Gtags' |
                "\ endif |
            "\ endif
        ""set tags=./tags,tags;$HOME
        "set tags=$HOME/.cache/tags
    " }

    " Vim-rooter {
        if isdirectory(expand("~/.vim/bundle/vim-rooter/"))
            let g:rooter_targets = 'Projects/,Course\ Work/,*'
            let g:rooter_patterns = ['.git/']
            let g:rooter_change_directory_for_non_project_files = 'current'
            let g:rooter_silent_chdir = 1
            let g:rooter_resolve_links = 1
        endif
    " }

    " AutoCloseTag {
        " Make it so AutoCloseTag works for xml and xhtml files as well
        au FileType xhtml,xml ru ftplugin/html/autoclosetag.vim
        nmap <Leader>ac <Plug>ToggleAutoCloseMappings
    " }

    " NerdTree {
        if isdirectory(expand("~/.vim/bundle/nerdtree"))
            let NERDTreeMapActivateNode = 'oo'
            let NERDTreeMapPreview = 'o'
            let NERDTreeMapPreviewVSplit = 'v'
            let NERDTreeMapOpenVSplit = 'vv'
            let NERDTreeMapOpenSplit = 'ss'
            let NERDTreeMapPreviewSplit = 's'
            let NERDTreeAutoDeleteBuffer = 1
            let NERDTreeMinimalUI = 1
            let NERDTreeChDirMode = 2

            map <C-q> <plug>NERDTreeTabsToggle<CR>
            nmap <leader>e :NERDTreeFind<CR>

            let NERDTreeShowBookmarks=1
            let NERDTreeIgnore=['\.py[cd]$', '\~$', '\.swo$', '\.swp$', '^\.git$', '^\.hg$', '^\.svn$', '\.bzr$']
            let NERDTreeIgnore+=['^\.DS_Store$', '^build$', '^gradle$', '^\.gradle$', '^\.idea$']
            let NERDTreeIgnore+=['^bin$', '\.cmake$', '^CMakeCache\.txt$', '^CMakeFiles$']
            let NERDTreeQuitOnOpen=1
            let NERDTreeMouseMode=2
            let NERDTreeShowHidden=1
            let NERDTreeKeepTreeInNewTab=1
            let g:nerdtree_tabs_open_on_gui_startup=0

            let g:NERDShutUp=1
            let g:NERDTreeIndicatorMapCustom = {
                        \ "Modified"  : "✹",
                        \ "Staged"    : "✚",
                        \ "Untracked" : "✭",
                        \ "Renamed"   : "➜",
                        \ "Unmerged"  : "═",
                        \ "Deleted"   : "✖",
                        \ "Dirty"     : "✗",
                        \ "Clean"     : "✔︎",
                        \ 'Ignored'   : '☒',
                        \ "Unknown"   : "?"
                        \ }

            " Initialize NERDTree as needed {
            function! NERDTreeInitAsNeeded()
                redir => bufoutput
                buffers!
                redir END
                let idx = stridx(bufoutput, "NERD_tree")
                if idx > -1
                    NERDTreeMirror
                    NERDTreeFind
                    wincmd l
                endif
            endfunction
            " }
        endif
    " }

    " defx {
        if isdirectory(expand("~/.vim/bundle/defx.nvim"))
            function! g:MaxLineLength()
                let l:max = 0
                for l:line in range(1, line('$'))
                    let l:len = len(getline(l:line))
                    if l:len > l:max
                        let l:max = l:len
                    endif
                endfor
                return l:max
            endfunction

            " Toggle between defx window width and longest line
            function! g:DefxToggleWidth(context) abort
                let l:max = MaxLineLength()
                execute 'vertical resize '. (l:max == winwidth('.') ? a:context['winwidth'] : l:max)
            endfunction

            call defx#custom#column('icon', {
                        \ 'root_icon': '√ ',
                        \ 'directory_icon': '',
                        \ 'opened_icon': '',
                        \ })

            call defx#custom#option('_', {
                        "\ 'root_marker': '√ ',
                        \ 'split': 'vertical',
                        \ 'winwidth': &columns/5,
                        \ 'direction': 'topleft',
                        \ 'columns': 'git:indent:icon:filename',
                        \ })

            call defx#custom#column('filename', {
                        \ 'min_width': 40,
                        \ 'max_width': 40,
                        \ })

            let g:defx_ignore = "*.py[cd],*~,*.swo,*.swp,.git,.hg,.svn,*.bzr,*.DS_Store,build,gradle,.gradle,.idea,bin,cmake-build*,CMakeCache.txt,CMakeFiles,.github,.travis,.clangd*"
            nnoremap <silent><leader>e :Defx -toggle -ignored-files=`g:defx_ignore` -search=`resolve(expand('%:p'))` `getcwd()` <CR>

            au! FileType defx call s:defx_my_settings()
            function! s:defx_my_settings() abort
                " Define mappings
                nnoremap <silent><buffer><expr> w       defx#do_action('call', 'DefxToggleWidth')
                nnoremap <silent><buffer><expr> oo      defx#do_action('multi', ['drop', 'quit'])
                nnoremap <silent><buffer><expr> o       defx#do_action('drop')
                nnoremap <silent><buffer><expr> <CR>    defx#is_directory() ?
                                                        \ defx#do_action('open_or_close_tree') :
                                                        \ defx#do_action('drop')
                nnoremap <silent><buffer><expr> v       defx#do_action('open','vsplit')
                nnoremap <silent><buffer><expr> vv      defx#do_action('multi', [['drop', 'vsplit'], 'quit'])
                nnoremap <silent><buffer><expr> h       defx#do_action('cd',['..'])
                nnoremap <silent><buffer><expr> l       defx#do_action('open_directory')
                nnoremap <silent><buffer><expr> y       defx#do_action('copy')
                nnoremap <silent><buffer><expr> m       defx#do_action('move')
                nnoremap <silent><buffer><expr> p       defx#do_action('paste')
                nnoremap <silent><buffer><expr> aa      defx#do_action('new_directory')
                nnoremap <silent><buffer><expr> a       defx#do_action('new_file')
                nnoremap <silent><buffer><expr> S       defx#do_action('toggle_sort','time')
                nnoremap <silent><buffer><expr> d       defx#do_action('remove')
                nnoremap <silent><buffer><expr> r       defx#do_action('rename')
                nnoremap <silent><buffer><expr> f       defx#do_action('search')
                nnoremap <silent><buffer><expr> !       defx#do_action('execute_command')
                nnoremap <silent><buffer><expr> x       defx#do_action('execute_system')
                nnoremap <silent><buffer><expr> yy      defx#do_action('yank_path')
                nnoremap <silent><buffer><expr> .       defx#do_action('toggle_ignored_files')
                nnoremap <silent><buffer><expr> ;       defx#do_action('repeat')
                nnoremap <silent><buffer><expr> q       defx#do_action('quit')
                nnoremap <silent><buffer><expr> j       line('.') == line('$') ? 'gg' : 'j'
                nnoremap <silent><buffer><expr> k       line('.') == 1 ? 'G' : 'k'
                nnoremap <silent><buffer><expr> <C-l>   defx#do_action('redraw')
                nnoremap <silent><buffer><expr> <C-g>   defx#do_action('print')
                nnoremap <silent><buffer><expr> cd      defx#do_action('change_vim_cwd')
            endfunction
        endif
    " }

    " defx-icons {
        if isdirectory(expand("~/.vim/bundle/defx-icons"))
            let g:defx_icons_enable_syntax_highlight = 0
            let g:defx_icons_column_length = 1
            let g:defx_icons_directory_icon = ''
            let g:defx_icons_mark_icon = '*'
            let g:defx_icons_parent_icon = ''
            let g:defx_icons_default_icon = ''
            let g:defx_icons_directory_symlink_icon = ''
            " Options below are applicable only when using "tree" feature
            let g:defx_icons_root_opened_tree_icon = ''
            let g:defx_icons_nested_opened_tree_icon = ''
            let g:defx_icons_nested_closed_tree_icon = ''
        endif
    " }

    " defx-git {
        if isdirectory(expand("~/.vim/bundle/defx-git"))
            hi def link Defx_git_Untracked Comment
            hi def link Defx_git_Ignored DiffAdd
            hi def link Defx_git_Renamed Title
            hi def link Defx_git_Modified Special
            hi def link Defx_git_Unmerged Label
            hi def link Defx_git_Deleted DiffDelete
            hi def link Defx_git_Staged Function
        endif
    " }

    " Session List {
        set sessionoptions=blank,buffers,curdir,folds,tabpages,winsize
        if isdirectory(expand("~/.vim/bundle/sessionman.vim/"))
            nmap <leader>sl :SessionList<CR>
            nmap <leader>ss :SessionSave<CR>
            nmap <leader>sc :SessionClose<CR>
        endif
    " }

    " JSON {
        nmap <leader>jt <Esc>:%!python -m json.tool<CR><Esc>:set filetype=json<CR>
        let g:vim_json_syntax_conceal = 0
    " }

    " PyMode {
        " Disable if python support not present
        if has('python3')
            let g:pymode_python = 'python3'
        else
            if !has('python2')
                let g:pymode = 0
            endif
        endif


        if isdirectory(expand("~/.vim/bundle/python-mode"))
            let g:pymode_lint = 0
            let g:pymode_trim_whitespaces = 0
            let g:pymode_options = 0
            let g:pymode_rope = 0
            let g:pymode_syntax_print_as_function = 1
        endif

        let g:pymode_options_max_line_length = 120
        let g:pymode_lint_options_pylint = {'max-line-length': g:pymode_options_max_line_length}
    " }

    " TagBar {
        if isdirectory(expand("~/.vim/bundle/tagbar/"))
            nnoremap <silent> <leader>tt :TagbarToggle<CR>
        endif
    "}

    " Rainbow {
                "\ 'ctermfgs': ['lightblue', 229, 'lightcyan', 'lightmagenta'],
        if isdirectory(expand("~/.vim/bundle/rainbow/"))
            let g:rainbow_conf = {
                \ 'guifgs': ['royalblue3', 'darkorange3', 'seagreen3', 'firebrick'],
                \ 'ctermfgs': ['darkblue', 'darkyellow', 'darkgreen', 'darkred'],
                \ 'operators': '_,_',
                \ 'parentheses': ['start=/(/ end=/)/ fold',
                \                 'start=/\[/ end=/\]/ fold',
                \                 'start=/{/ end=/}/ fold'],
                \ 'separately': {
                \     '*': {},
                \     'tex': {
                \         'parentheses': [['(',')'], ['\[','\]'], ['\\begin{.*}','\\end{.*}']],
                \     },
                \     'lisp': {
                \         'guifgs': ['royalblue', 'darkorange', 'seagreen', 'firebrick', 'darkorchid'],
                \     },
                \     'vim': {
                \         'parentheses': ['start=/(/ end=/)/',
                \                         'start=/\[/ end=/\]/',
                \                         'start=/{/ end=/}/ fold',
                \                         'start=/(/ end=/)/ containedin=vimFuncBody',
                \                         'start=/\[/ end=/\]/ containedin=vimFuncBody',
                \                         'start=/{/ end=/}/ fold containedin=vimFuncBody'],
                \     },
                \     'html': {
                \         'parentheses': ['start=/\v\<((area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)[ >])@!\z([-_:a-zA-Z0-9]+)(\s+[-_:a-zA-Z0-9]+(\=("[^"]*"|'."'".'[^'."'".']*'."'".'|[^ '."'".'"><=`]*))?)*\>/ end=#</\z1># fold'],
                \     },
                \     'css': 0,
                \ },
            \ }
            let g:rainbow_active = 1 "0 if you want to enable it later via :RainbowToggle
        endif
    "}

    " Airline {
        " Use the powerline theme and optionally enable powerline symbols.
        " To use the symbols , , , , , , and .in the statusline

        if isdirectory(expand("~/.vim/bundle/vim-airline-themes/"))
            if !exists('g:airline_theme')
                let g:airline_theme = 'gruvbox'
            endif

            let g:airline_highlighting_cache = 1
            let g:airline_powerline_fonts = 0
            let g:bufferline_echo = 0
            let g:airline_detect_spell = 0

            " extensions
            let g:airline#extensions#bufferline#enabled = 0
            let g:airline#extensions#tabline#enabled = 1
            let g:airline#extensions#tabline#fnamemod = ':t'
            let g:airline#extensions#tabline#left_alt_sep = '│'
            let g:airline#extensions#tabline#buffer_idx_mode = 1
            let g:airline#extensions#branch#enabled = 1
            let g:airline#extensions#branch#format = 2
            let g:airline#extensions#tagbar#enabled = 1
            let g:airline#extensions#whitespace#mixed_indent_algo = 2
            let g:airline#extensions#ale#enabled = 1
            let g:airline#extensions#coc#enabled = 1


            " Unicode symbols
            if !exists('g:airline_symbols')
                let g:airline_symbols = {}
            endif
            let g:Powerline_symbols = 'unicode'
            let g:Powerline_symbols = 'fancy'
            let g:airline_symbols.crypt = '🔒'
            let g:airline_symbols.branch = ''
            let g:airline_symbols.paste = '∥'
            let g:airline_symbols.notexists = '∄'
            let g:airline_symbols.whitespace = 'Ξ'
            let g:airline_symbols.space = "\ua0"
            let g:airline_symbols.linenr = '⭡'

            " Tabline key mappings
            nmap <leader>1 <Plug>AirlineSelectTab1
            nmap <leader>2 <Plug>AirlineSelectTab2
            nmap <leader>3 <Plug>AirlineSelectTab3
            nmap <leader>4 <Plug>AirlineSelectTab4
            nmap <leader>5 <Plug>AirlineSelectTab5
            nmap <leader>6 <Plug>AirlineSelectTab6
            nmap <leader>7 <Plug>AirlineSelectTab7
            nmap <leader>8 <Plug>AirlineSelectTab8
            nmap <leader>9 <Plug>AirlineSelectTab9
            nmap – <Plug>AirlineSelectPrevTab
            nmap ≠ <Plug>AirlineSelectNextTab

            " Sections
            let g:airline_section_x = airline#section#create_right(['tagbar'])
            let g:airline_section_y = airline#section#create(['filetype'])
            "let g:airline_section_z = '%3p%% %{g:airline_symbols.linenr} %l/%L : %c'
        endif
    " }

    " ALE {
        if isdirectory(expand("~/.vim/bundle/ale/"))
            let g:ale_linters_explicit = 0
            let g:ale_lint_on_text_changed = 'normal'
            let g:ale_lint_delay = 0
            let g:ale_set_loclist = 1
            let g:ale_set_quickfix = 0
            let g:ale_sign_error = '✗'
            let g:ale_sign_warning = '▲'
            let g:ale_sign_info = '●'
            if g:colors_name == 'gruvbox'
                highlight link ALEErrorSign GruvboxRedSign
                highlight link ALEWarningSign GruvboxYellowSign
                highlight link ALEInfoSign GruvboxAquaSign
            endif
            let g:ale_statusline_format = ['✗ %d', '▲ %d', '✓ OK']

            let g:ale_linters = {
                        \ 'java': [],
                        \ 'cpp': [],
                        \ 'python': ['flake8', 'pylint'],
                        \}

            let g:ale_fixers = {
                        \ '*': ['remove_trailing_lines', 'trim_whitespace'],
                        \}
            let g:ale_fix_on_save = 1

            if g:ale_completion_enabled == 1
                nnoremap <silent> <leader>dl :ALEGoToDefinition <CR>
                nnoremap <silent> <leader>re :ALEFindReferences <CR>
                nnoremap <silent> <leader>fo :ALEFix<CR>

                set omnifunc=ale#completion#OmniFunc
                nmap <silent> <C-k> <Plug>(ale_previous_wrap)
                nmap <silent> <C-j> <Plug>(ale_next_wrap)
            endif
        endif
    " }

    " Diminactive {
        if isdirectory(expand("~/.vim/bundle/vim-diminactive/"))
            let g:diminactive_use_colorcolumn = 1
            let g:diminactive_use_syntax = 0
        endif
    " }

    " Latex preview {
        if isdirectory(expand("~/.vim/bundle/vim-latex-live-preview/"))
            let g:livepreview_previewer = 'open -a Preview'
            command! LLP LLPStartPreview
            let g:livepreview_engine = 'pdflatex'
            "autocmd! Filetype tex setl updatetime=1
            augroup RemoveTemp
                autocmd! FileType tex
                    \ autocmd! BufUnload <buffer> silent !rm -rf $TMPDIR/vim-latex-live-preview-*
            augroup END
        endif
    " }

    " LeaderF {
        if isdirectory(expand("~/.vim/bundle/LeaderF/"))
            let g:Lf_StlSeparator = { 'left': '⮀', 'right': '⮂' }
            let g:Lf_StlColorscheme = 'default'
            let g:Lf_RootMarkers = ['.project', '.root', '.git', '.svn']
            let g:Lf_WorkingDirectoryMode = 'Ac'
            if executable('ag')
                let g:Lf_DefaultExternalTool = "ag"
            endif
            if has('maxunix')
                let g:Lf_Ctags = '/usr/local/bin/ctags'
            endif
            let g:Lf_CacheDirectory = $HOME . '/.cache'
            let g:Lf_UseCache = 0
            let g:Lf_UseMemoryCache = 0
            let g:Lf_WildIgnore = {
                \ 'dir': ['.svn','.git','.hg', 'Music', 'Movies', 'Public', 'Pictures'],
                \ 'file': ['~$*','*.bak','*.exe','*.o','*.a','*.so','*.py[co]','.DS_Store', '*.pyc', '*.dat', '*.dll', '*.jpg', '*.png']
                \ }

            " Key mapping
            let g:Lf_ShortcutF = '<leader>f<space>'
            nnoremap <leader>ff :LeaderfFunction<CR>
            nnoremap <leader>r<space> :LeaderfMru<CR>
        endif
    " }

    " Auto-pairs {
        if isdirectory(expand("~/.vim/bundle/auto-pairs"))
            let g:AutoPairsFlyMode = 0
            let g:AutoPairsMapCh = 0
        endif
    " }

    " FastFold {
        if isdirectory(expand("~/.vim/bundle/FastFold/"))
            let g:tex_fold_enabled=1
            let g:vimsyn_folding='af'
            let g:fastfold_fold_command_suffixes = []
            nmap zuz <Plug>(FastFoldUpdate)
        endif
    " }

    " IndentLine {
        if isdirectory(expand("~/.vim/bundle/indentLine/"))
            let g:indentLine_enabled = 1
            let g:indentLine_faster = 0
            let g:indentLine_char = '│'    " Can be ¦, ┆, │, ⎸, or ▏
            let g:indentLine_fileTypeExclude = ['startify', 'defx', 'text']
            let g:indentLine_bufTypeExclude = ['help', 'terminal']
            let g:indentLine_concealcursor = ''
        endif
    " }

    " Startify {
        if isdirectory(expand("~/.vim/bundle/vim-startify/"))
            let g:startify_custom_header = [
                            \'',
                            \'',
                            \'                          /##    /##/##                                             ',
                            \'                         | ##   | #|__/                                             ',
                            \'                         | ##   | ##/##/######/####                                 ',
                            \'                         |  ## / ##| #| ##_  ##_  ##                                ',
                            \'                          \  ## ##/| #| ## \ ## \ ##                                ',
                            \'                           \  ###/ | #| ## | ## | ##                                ',
                            \'                            \  #/  | #| ## | ## | ##                                ',
                            \'                             \_/   |__|__/ |__/ |__/    version : ' . v:version . ' ',
                            \'',
                            \ ]
            let g:startify_session_dir = $HOME .  '/.vim/' . '/sessions'
            let g:startify_files_number = 6
            let g:startify_list_order = [
                        \ ['   MRU files in the current directory:'],
                        \ 'dir',
                        \ ['   MRU files:'],
                        \ 'files',
                        \ ['   Sessions:'],
                        \ 'sessions',
                        \ ['   Bookmarks:'],
                        \ 'bookmarks',
                        \ ]
            let g:startify_bookmarks = [ {'c': '~/.vim/vimrc'},
                                       \ {'cc': '~/.vim/vimrc.bundles'},
                                       \ {'d': '~/Documents/Projects/'},
                                       \ ]
            let g:startify_update_oldfiles = 1
            let g:startify_disable_at_vimenter = 0
            let g:startify_session_autoload = 1
            let g:startify_session_persistence = 1
            "let g:startify_session_delete_buffers = 0
            let g:startify_change_to_dir = 0
            "let g:startify_change_to_vcs_root = 0  " vim-rooter has same feature
            let g:startify_skiplist = [
                \ 'COMMIT_EDITMSG',
                \ escape(fnamemodify(resolve($VIMRUNTIME), ':p'), '\') .'doc',
                \ 'bundle/.*/doc',
                \ ]
            autocmd! FileType startify nnoremap <buffer> <F2> <Nop>
            autocmd! FileType startify setl nowrap

        endif
    " }

    " AsyncRun {
        if isdirectory(expand("~/.vim/bundle/asyncrun.vim"))
            nnoremap <leader>a :AsyncRun<space>
            nnoremap <C-c>: AsyncStop<CR>
            let g:asyncrun_open = 16
        endif
    "}
    "
    " vim-tmux-navigator {
        let g:tmux_navigator_no_mappings = 1
        let g:tmux_navigator_disable_when_zoomed = 1

        nnoremap <silent> ˙ :TmuxNavigateLeft<cr>
        nnoremap <silent> ∆ :TmuxNavigateDown<cr>
        nnoremap <silent> ˚ :TmuxNavigateUp<cr>
        nnoremap <silent> ¬ :TmuxNavigateRight<cr>
        nnoremap <silent> « :TmuxNavigatePrevious<cr>
    " }

    " Completion {

        " Tab completion
        inoremap <expr> <Tab>   pumvisible() ? "\<C-n>" : "\<Tab>"
        inoremap <expr> <S-Tab> pumvisible() ? "\<C-p>" : "\<S-Tab>"

        " Some convenient mappings
        inoremap <expr> <cr>   pumvisible() ? "\<C-y>" : "\<C-g>u\<CR>"
        inoremap <expr> <Down> pumvisible() ? "\<C-n>" : "\<Down>"
        inoremap <expr> <Up>   pumvisible() ? "\<C-p>" : "\<Up>"
        inoremap <expr> <C-d>  pumvisible() ? "\<PageDown>\<C-p>\<C-n>" : "\<C-d>"
        inoremap <expr> <C-u>  pumvisible() ? "\<PageUp>\<C-p>\<C-n>" : "\<C-u>"

        " Automatically open and close the popup menu / preview window
        au! CompleteDone,CursorMovedI,InsertLeave * if pumvisible() == 0|silent! pclose|endif

        set completeopt=menu,longest

        " Remap Ultisnips
        let g:UltiSnipsExpandTrigger = '<C-j>'
        let g:UltiSnipsJumpForwardTrigger = '<C-j>'
        let g:UltiSnipsJumpBackwardTrigger = '<C-k>'

        " YouCompleteMe {
            let g:loaded_youcompleteme = 1  " Disable
            if isdirectory(expand("~/.vim/bundle/YouCompleteMe/"))
                let g:acp_enableAtStartup = 0

                let g:ycm_global_ycm_extra_conf = '$HOME/.vim/ycm_extra_conf.py'
                let g:ycm_confirm_extra_conf = 0

                let g:ycm_always_populate_location_list = 1
                let g:ycm_complete_in_comments = 1
                let g:ycm_collect_identifiers_from_comments_and_strings = 0
                let g:ycm_collect_identifiers_from_tags_files = 0
                let g:ycm_max_num_candidates = 20
                let g:ycm_max_num_identifier_candidates = 20
                let g:ycm_add_preview_to_completeopt = 0
                let g:ycm_autoclose_preview_window_after_completion = 0
                let g:ycm_autoclose_preview_window_after_insertion = 1

                nnoremap <C-j> :lnext <CR>
                nnoremap <C-k> :lprevious <CR>

                " clangd config
                " Let clangd fully control code completion
                let g:ycm_clangd_uses_ycmd_caching = 1
                " Use installed clangd, not YCM-bundled clangd which doesn't get updates.
                let g:ycm_clangd_binary_path = exepath("clangd")
                let g:ycm_clangd_args = [
                            \ '-log=error',
                            \ '-pretty',
                            "\ '-background-index',
                            \ '-j=2',
                            \ '-pch-storage=memory',
                            \ '-function-arg-placeholders=1',
                            \ '-header-insertion-decorators=1'
                            \ ]

                " Enable omni completion.
                "autocmd! FileType css setlocal omnifunc=csscomplete#CompleteCSS
                autocmd! FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
                "autocmd! FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
                autocmd! FileType python setlocal omnifunc=pythoncomplete#Complete
                "autocmd! FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
                "autocmd! FileType ruby setlocal omnifunc=rubycomplete#Complete
                "autocmd! FileType haskell setlocal omnifunc=necoghc#omnifunc

                " For snippet_complete marker.
                if has('conceal')
                    set conceallevel=2 concealcursor=i
                endif

                nnoremap <silent> <leader>dl :YcmCompleter GoTo <CR>
                nnoremap <silent> <leader>df :YcmCompleter GoToDefinition <CR>
                nnoremap <silent> <leader>fi :YcmCompleter FixIt <CR>
                nnoremap <silent> <leader>re :YcmCompleter GoToReferences <CR>
                nnoremap <silent> <leader>fo :YcmCompleter Format <CR>
                vnoremap <silent> <leader>fo :YcmCompleter Format <CR>
                nnoremap <leader>rn :YcmCompleter RefactorRename<space>
                nnoremap <leader>rs :YcmRestartServer<CR>

                " Disable the neosnippet preview candidate window
                " When enabled, there can be too much visual noise
                " especially when splits are used.
                set completeopt-=preview
            endif
        " }

        " Coc {
            if isdirectory(expand("~/.vim/bundle/coc.nvim/"))
                set signcolumn=yes
                function! s:show_documentation()
                    if (index(['vim','help'], &filetype) >= 0)
                        execute 'h '.expand('<cword>')
                    else
                        call CocAction('doHover')
                    endif
                endfunction

                nmap <silent> <leader>dl <Plug>(coc-definition)
                nmap <silent> <leader>re <Plug>(coc-references)
                nmap <silent> <leader>fi <Plug>(coc-fix-current)
                xmap <silent> <leader>fo <Plug>(coc-format-selected)
                nmap <silent> <leader>dd <Plug>(coc-diagnostic-info)
                nmap <silent> <C-j>      <Plug>(coc-diagnostic-next)
                nmap <silent> <C-k>      <Plug>(coc-diagnostic-prev)
                nmap <leader>rn <Plug>(coc-rename)
                nnoremap <silent> <leader>fo :call CocAction('format') <CR>
                nnoremap <silent> <leader>rs :CocRestart <CR>
                nnoremap <silent> <leader>ho :call <SID>show_documentation() <CR>
                nnoremap <silent> <leader>da :<C-u>CocList diagnostics<cr>

                hi def link CocErrorSign GruvboxRedSign
                hi def link CocWarningSign GruvboxYellowSign
                hi def link CocInfoSign GruvboxAquaSign
                hi def link CocHintSign GruvboxYellowSign
            endif
        " }
    "}

    " echodoc {
        let g:echodoc#enable_at_startup = 1
        if isdirectory(expand("~/.vim/bundle/echodoc.vim")) && g:echodoc#enable_at_startup == 1
            let g:echodoc#type = "echo"
        endif
    " }

    " FZF {
        if executable("fzf")
            set rtp+=/usr/local/opt/fzf

            let g:fzf_layout = {
                        \ 'down': '~30%',
                        \ }
            let g:fzf_colors =
                        \ { 'fg':    ['fg', 'Normal'],
                        \ 'bg':      ['bg', 'Normal'],
                        \ 'hl':      ['fg', 'Comment'],
                        \ 'fg+':     ['fg', 'CursorLine', 'CursorColumn', 'Normal'],
                        \ 'bg+':     ['bg', 'CursorLine', 'CursorColumn'],
                        \ 'hl+':     ['fg', 'Statement'],
                        \ 'info':    ['fg', 'PreProc'],
                        \ 'border':  ['fg', 'Ignore'],
                        \ 'prompt':  ['fg', 'Conditional'],
                        \ 'pointer': ['fg', 'Exception'],
                        \ 'marker':  ['fg', 'Keyword'],
                        \ 'spinner': ['fg', 'Label'],
                        \ 'header':  ['fg', 'Comment'] }

            command! -bang -nargs=* Ag call fzf#vim#ag
                        \ (
                        \ <q-args>,
                        \ '--color-path "0;34" --color-line-number "0;35" --color-match "1;33"',
                        \ { 'options': ['--color', 'hl:#9d0006,hl+:#9d0006'] },
                        \ <bang>0
                        \ )

            " key mappings
            nnoremap <leader>f<space> :FZF <CR>
            nnoremap <leader>r<space> :History <CR>
            nnoremap <leader>ff :BTags <CR>
            nnoremap <leader>b<space> :Buffers <CR>
            nnoremap <leader>l<space> :Lines <CR>
            " Bind K to grep word under cursor
            nnoremap K :call fzf#vim#ag
                        \ (
                        \ expand('<cword>'),
                        \ '--color-path "0;34" --color-line-number "0;35" --color-match "1;33"',
                        \ { 'options': ['--color', 'hl:#9d0006,hl+:#9d0006'] },
                        \ ) <CR>
        endif
    " }
" }

" GUI Settings {

    " GVIM- (here instead of .gvimrc)
    if has('gui_running')
        set guioptions-=T           " Remove the toolbar
        set lines=40                " 40 lines of text instead of 24
    endif

" }
